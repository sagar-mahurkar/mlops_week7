name: Manual Stress Test Pipeline

on:
  workflow_dispatch:
    # Allows triggering manually from the GitHub Actions tab

permissions:
  contents: write # Required for CML to write comments
  id-token: write # Required for GCP authentication

env:
  # --- GKE Deployment Configuration (Updated to match first file's variable names) ---
  PROJECT_ID: lively-nimbus-473407-m9
  GAR_LOCATION: us-central1         
  REPOSITORY: my-repo
  IMAGE: iris-api         
  CLUSTER_NAME: demo-gke-iris-cluster  
  CLUSTER_LOCATION: us-central1   
  # NOTE: The DEPLOYMENT_NAME is used for K8s object names (HPA, SVC, Deployment)
  DEPLOYMENT_NAME: iris-fastapi-deployment
  SERVICE_NAME: iris-fastapi-service
  HPA_NAME: iris-fastapi-hpa         
  NAMESPACE: default

jobs:
  # ==========================================================
  # JOB 1: STRESS TESTING AND HPA DEMO
  # Runs the test against the existing, deployed application
  # ==========================================================
  stress-test:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup CML
        uses: iterative/setup-cml@v2.0.1
        
      - name: Google Cloud Authentication
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS_JSON }}

      - name: Get GKE Credentials (Configure kubectl)
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.CLUSTER_NAME }}
          location: ${{ env.CLUSTER_LOCATION }}

      # -----------------------------------------------------
      # PREREQUISITES: INSTALL WRK AND GET EXTERNAL IP
      # -----------------------------------------------------
      - name: Install wrk (HTTP benchmarking tool)
        run: sudo apt-get update && sudo apt-get install -y wrk

      - name: Get Service External IP (Immediate Check)
        id: get_ip
        run: |
          # Use SERVICE_NAME environment variable
          EXTERNAL_IP=$(kubectl get svc ${{ env.SERVICE_NAME }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -z "$EXTERNAL_IP" ]; then
            echo "Error: External IP not found immediately. Ensure LoadBalancer is ready."
            exit 1
          fi
          echo "::set-output name=external_ip::$EXTERNAL_IP"
          echo "External IP found: $EXTERNAL_IP"
          
      # -----------------------------------------------------
      # SCENARIO 1: HPA DEMONSTRATION (Max Pods: 3)
      # -----------------------------------------------------
      - name: Configure HPA for Max Pods 3 and Stress Test (1000+ Requests)
        id: scenario_1
        run: |
          EXTERNAL_URL="http://${{ steps.get_ip.outputs.external_ip }}"
          TARGET_ENDPOINT="${EXTERNAL_URL}/live_check" # <-- CHANGED TO /live_check
          echo "## ðŸ“ˆ SCENARIO 1: HPA Scaling (Max Pods: 3)" > stress_report.md
          
          # 1. Ensure HPA maxReplicas is 3 - Use HPA_NAME env variable
          kubectl patch hpa/${{ env.HPA_NAME }} -p '{"spec":{"maxReplicas": 3}}' --namespace ${{ env.NAMESPACE }}
          echo "HPA set to maxReplicas=3. Deployment scaled to 1 initially."
          kubectl get hpa ${{ env.HPA_NAME }} --namespace ${{ env.NAMESPACE }}
          
          # 2. Run wrk: sustained load (120 connections for 2 mins)
          echo "Starting stress test on $TARGET_ENDPOINT for 2 minutes to trigger HPA..."
          wrk -t4 -c1000 -d30s $TARGET_ENDPOINT > wrk_results_1.txt
          
          # 3. Write CML Report for Scenario 1 - Dump Raw Output
          echo "The load test ran for **2 minutes (120 seconds)** with 120 concurrent connections hitting \`/live_check\`." >> stress_report.md
          echo "" >> stress_report.md
          echo "### Test 1 Results (Raw wrk Output):" >> stress_report.md
          echo "\`\`\`text" >> stress_report.md
          # Dumps the complete wrk output
          cat wrk_results_1.txt >> stress_report.md
          echo "\`\`\`" >> stress_report.md
          
          # 4. Observe Scaling (Wait for HPA to act)
          echo "Waiting 60s to observe scaling..." >> stress_report.md
          sleep 60
          echo "### Kubernetes Status After Scaling Attempt:" >> stress_report.md
          kubectl get deployment ${{ env.DEPLOYMENT_NAME }} -o wide --namespace ${{ env.NAMESPACE }} >> stress_report.md
          kubectl get hpa ${{ env.HPA_NAME }} -o wide --namespace ${{ env.NAMESPACE }} >> stress_report.md

      # -----------------------------------------------------
      # SCENARIO 2: BOTTLENECK OBSERVATION (Max Pods: 1, Concurrency 2000)
      # -----------------------------------------------------
      - name: Restrict HPA to Max Pods 1 and Stress Test (Concurrency 2000)
        id: scenario_2
        run: |
          EXTERNAL_URL="http://${{ steps.get_ip.outputs.external_ip }}"
          TARGET_ENDPOINT="${EXTERNAL_URL}/live_check" # <-- CHANGED TO /live_check
          echo -e "\n\n---" >> stress_report.md
          echo "## ðŸš¨ SCENARIO 2: Bottleneck (Max Pods: 1, Concurrency: 2000)" >> stress_report.md
          
          # 1. Restrict scaling - Use DEPLOYMENT_NAME and HPA_NAME env variables
          kubectl scale deployment/${{ env.DEPLOYMENT_NAME }} --replicas=1 --namespace ${{ env.NAMESPACE }} # Scale down
          kubectl patch hpa/${{ env.HPA_NAME }} -p '{"spec":{"maxReplicas": 1}}' --namespace ${{ env.NAMESPACE }}
          echo "HPA restricted to maxReplicas=1."
          sleep 30 # Give K8s time to adjust
          
          # 2. Run wrk: high concurrency bottleneck test (2000 connections)
          echo "Starting bottleneck test on $TARGET_ENDPOINT with concurrency 2000..."
          wrk -t4 -c2000 -d10s $TARGET_ENDPOINT > wrk_results_2.txt
          
          # 3. Write CML Report for Scenario 2 - Dump Raw Output
          echo "This test uses extreme concurrency (2000 connections) hitting \`/live_check\` against a single replica." >> stress_report.md
          echo "" >> stress_report.md
          echo "### Test 2 Results (Raw wrk Output):" >> stress_report.md
          echo "\`\`\`text" >> stress_report.md
          # Dumps the complete wrk output
          cat wrk_results_2.txt >> stress_report.md
          echo "\`\`\`" >> stress_report.md
          
          # 4. Observe Scaling (Should remain 1 pod)
          echo "### Kubernetes Status After Bottleneck Test (Should remain 1 replica):" >> stress_report.md
          kubectl get deployment ${{ env.DEPLOYMENT_NAME }} -o wide --namespace ${{ env.NAMESPACE }} >> stress_report.md
          kubectl get hpa ${{ env.HPA_NAME }} -o wide --namespace ${{ env.NAMESPACE }} >> stress_report.md
          
      - name: Create CML Report Comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: cml comment create stress_report.md
